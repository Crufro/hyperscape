/**
 * Manifest Parser for Game Import
 *
 * Parses game manifest JSON files (items.json, npcs.json, etc.) and converts
 * them to HyperForge asset format. Tracks which assets originate from the game
 * vs those generated by HyperForge.
 */

import type { AssetCategory, Rarity, EquipSlot, WeaponType, AttackType } from "@/types/core";
import type { HyperForgeAsset, CDNAsset } from "@/types/asset";
import type {
  ItemDefinition,
  NpcDefinition,
  ResourceDefinition,
  StoreDefinition,
  MusicTrack,
} from "@/lib/game/manifests";
import { logger } from "@/lib/utils";

const log = logger.child("ManifestParser");

// =============================================================================
// TYPE DEFINITIONS
// =============================================================================

/**
 * Parsed asset with source tracking
 */
export interface ParsedGameAsset {
  /** HyperForge asset representation */
  asset: CDNAsset;
  /** Original manifest type */
  manifestType: "items" | "npcs" | "resources" | "stores" | "music";
  /** Original raw data from manifest */
  rawData: ItemDefinition | NpcDefinition | ResourceDefinition | StoreDefinition | MusicTrack;
  /** Last sync timestamp */
  lastSynced?: Date;
}

/**
 * Result of parsing all manifests
 */
export interface ParsedManifests {
  items: ParsedGameAsset[];
  npcs: ParsedGameAsset[];
  resources: ParsedGameAsset[];
  stores: ParsedGameAsset[];
  music: ParsedGameAsset[];
  totalCount: number;
  parsedAt: Date;
}

// =============================================================================
// ITEM MANIFEST PARSER
// =============================================================================

/**
 * Map item type from manifest to HyperForge category
 */
function mapItemTypeToCategory(type: string): AssetCategory {
  switch (type.toLowerCase()) {
    case "weapon":
      return "weapon";
    case "armor":
      return "armor";
    case "tool":
      return "tool";
    case "resource":
    case "material":
      return "item";
    case "currency":
      return "currency";
    default:
      return "item";
  }
}

/**
 * Map manifest rarity to HyperForge rarity
 */
function mapRarity(rarity: string | undefined): Rarity {
  switch (rarity?.toLowerCase()) {
    case "common":
      return "common";
    case "uncommon":
      return "uncommon";
    case "rare":
      return "rare";
    case "very_rare":
    case "epic":
      return "epic";
    case "legendary":
      return "legendary";
    case "unique":
      return "unique";
    default:
      return "common";
  }
}

/**
 * Map manifest equip slot to HyperForge equip slot
 */
function mapEquipSlot(slot: string | undefined): EquipSlot | undefined {
  if (!slot) return undefined;
  switch (slot.toLowerCase()) {
    case "head":
      return "head";
    case "body":
    case "chest":
      return "chest";
    case "legs":
      return "legs";
    case "feet":
      return "feet";
    case "hands":
      return "hands";
    case "cape":
      return "cape";
    case "neck":
    case "amulet":
      return "neck";
    case "ring":
      return "ring";
    case "weapon":
    case "mainhand":
      return "mainhand";
    case "shield":
    case "offhand":
      return "offhand";
    case "ammo":
      return "ammo";
    default:
      return undefined;
  }
}

/**
 * Map manifest weapon type to HyperForge weapon type
 */
function mapWeaponType(type: string | undefined): WeaponType | undefined {
  if (!type) return undefined;
  switch (type.toUpperCase()) {
    case "SWORD":
      return "sword";
    case "AXE":
      return "axe";
    case "MACE":
      return "mace";
    case "DAGGER":
      return "dagger";
    case "SPEAR":
      return "spear";
    case "BOW":
      return "bow";
    case "CROSSBOW":
      return "crossbow";
    case "STAFF":
      return "staff";
    case "WAND":
      return "wand";
    default:
      return undefined;
  }
}

/**
 * Map manifest attack type to HyperForge attack type
 */
function mapAttackType(type: string | undefined): AttackType | undefined {
  if (!type) return undefined;
  switch (type.toUpperCase()) {
    case "MELEE":
      return "melee";
    case "RANGED":
      return "ranged";
    case "MAGIC":
      return "magic";
    default:
      return undefined;
  }
}

/**
 * Parse items.json manifest to HyperForge assets
 */
export function parseItemsManifest(items: ItemDefinition[]): ParsedGameAsset[] {
  log.debug("Parsing items manifest", { count: items.length });

  return items.map((item) => {
    const category = mapItemTypeToCategory(item.type);
    
    const asset: CDNAsset = {
      id: item.id,
      name: item.name,
      source: "CDN",
      category,
      description: item.description || item.examine,
      modelPath: item.modelPath || "",
      iconPath: item.iconPath,
      thumbnailPath: item.thumbnailPath || item.iconPath,
      rarity: mapRarity(item.rarity),
      type: item.type,
      examine: item.examine,
      value: item.value,
      weight: item.weight,
      stackable: item.stackable,
      tradeable: item.tradeable,
      equipSlot: mapEquipSlot(item.equipSlot),
      weaponType: mapWeaponType(item.weaponType),
      attackType: mapAttackType(item.attackType),
      equippedModelPath: item.equippedModelPath,
      bonuses: item.bonuses,
      requirements: item.requirements,
    };

    return {
      asset,
      manifestType: "items" as const,
      rawData: item,
      lastSynced: new Date(),
    };
  });
}

// =============================================================================
// NPC MANIFEST PARSER
// =============================================================================

/**
 * Parse npcs.json manifest to HyperForge assets
 */
export function parseNPCsManifest(npcs: NpcDefinition[]): ParsedGameAsset[] {
  log.debug("Parsing NPCs manifest", { count: npcs.length });

  return npcs.map((npc) => {
    // Determine category based on NPC type
    const category: AssetCategory = npc.category === "mob" ? "mob" : "npc";
    
    // Extract model path from appearance or direct field
    const modelPath = npc.appearance?.modelPath || npc.modelPath || "";
    const iconPath = npc.appearance?.iconPath || npc.iconPath;
    
    const asset: CDNAsset = {
      id: npc.id,
      name: npc.name,
      source: "CDN",
      category,
      description: npc.description,
      modelPath,
      iconPath,
      thumbnailPath: npc.thumbnailPath || iconPath,
      npcCategory: npc.category === "mob" ? "monster" : "merchant",
      faction: npc.faction,
      level: npc.stats?.level || npc.level,
      combatLevel: npc.stats?.level || npc.combatLevel,
      attackable: npc.combat?.attackable,
    };

    return {
      asset,
      manifestType: "npcs" as const,
      rawData: npc,
      lastSynced: new Date(),
    };
  });
}

// =============================================================================
// RESOURCE MANIFEST PARSER
// =============================================================================

/**
 * Parse resources.json manifest to HyperForge assets
 */
export function parseResourcesManifest(resources: ResourceDefinition[]): ParsedGameAsset[] {
  log.debug("Parsing resources manifest", { count: resources.length });

  return resources.map((resource) => {
    const asset: CDNAsset = {
      id: resource.id,
      name: resource.name,
      source: "CDN",
      category: "resource",
      description: resource.examine,
      modelPath: resource.modelPath || "",
      examine: resource.examine,
      type: resource.type,
      harvestSkill: resource.harvestSkill,
      toolRequired: resource.toolRequired,
      levelRequired: resource.levelRequired,
    };

    return {
      asset,
      manifestType: "resources" as const,
      rawData: resource,
      lastSynced: new Date(),
    };
  });
}

// =============================================================================
// STORE MANIFEST PARSER
// =============================================================================

/**
 * Store item definition for import
 */
interface StoreItemAsset {
  storeId: string;
  storeName: string;
  itemId: string;
  name: string;
  price: number;
  stockQuantity: number;
  description: string;
  category: string;
}

/**
 * Parse stores.json manifest - stores are not directly assets but reference items
 * Returns the store definitions which can be used to verify item availability
 */
export function parseStoresManifest(stores: StoreDefinition[]): ParsedGameAsset[] {
  log.debug("Parsing stores manifest", { count: stores.length });

  // For stores, we create a pseudo-asset representing each store
  return stores.map((store) => {
    const asset: CDNAsset = {
      id: store.id,
      name: store.name,
      source: "CDN",
      category: "building",
      description: store.description,
      modelPath: "", // Stores don't have direct models
      type: "store",
    };

    return {
      asset,
      manifestType: "stores" as const,
      rawData: store,
      lastSynced: new Date(),
    };
  });
}

/**
 * Get all items referenced by stores
 */
export function getStoreItems(stores: StoreDefinition[]): StoreItemAsset[] {
  const items: StoreItemAsset[] = [];
  
  for (const store of stores) {
    for (const item of store.items) {
      items.push({
        storeId: store.id,
        storeName: store.name,
        itemId: item.itemId,
        name: item.name,
        price: item.price,
        stockQuantity: item.stockQuantity,
        description: item.description,
        category: item.category,
      });
    }
  }
  
  return items;
}

// =============================================================================
// MUSIC MANIFEST PARSER
// =============================================================================

/**
 * Parse music.json manifest to HyperForge assets
 */
export function parseMusicManifest(tracks: MusicTrack[]): ParsedGameAsset[] {
  log.debug("Parsing music manifest", { count: tracks.length });

  return tracks.map((track) => {
    const asset: CDNAsset = {
      id: track.id,
      name: track.name,
      source: "CDN",
      category: "music",
      description: track.description,
      modelPath: track.path, // For music, modelPath holds the audio path
      type: track.type,
    };

    return {
      asset,
      manifestType: "music" as const,
      rawData: track,
      lastSynced: new Date(),
    };
  });
}

// =============================================================================
// COMBINED PARSER
// =============================================================================

/**
 * Parse all manifests and return combined result
 */
export function parseAllManifests(data: {
  items?: ItemDefinition[];
  npcs?: NpcDefinition[];
  resources?: ResourceDefinition[];
  stores?: StoreDefinition[];
  music?: MusicTrack[];
}): ParsedManifests {
  log.info("Parsing all manifests");

  const items = data.items ? parseItemsManifest(data.items) : [];
  const npcs = data.npcs ? parseNPCsManifest(data.npcs) : [];
  const resources = data.resources ? parseResourcesManifest(data.resources) : [];
  const stores = data.stores ? parseStoresManifest(data.stores) : [];
  const music = data.music ? parseMusicManifest(data.music) : [];

  const result: ParsedManifests = {
    items,
    npcs,
    resources,
    stores,
    music,
    totalCount: items.length + npcs.length + resources.length + stores.length + music.length,
    parsedAt: new Date(),
  };

  log.info("Manifests parsed", {
    items: items.length,
    npcs: npcs.length,
    resources: resources.length,
    stores: stores.length,
    music: music.length,
    total: result.totalCount,
  });

  return result;
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Get asset ID from a parsed game asset
 */
export function getAssetId(parsed: ParsedGameAsset): string {
  return parsed.asset.id;
}

/**
 * Check if an asset has a valid model path
 */
export function hasValidModel(parsed: ParsedGameAsset): boolean {
  const modelPath = parsed.asset.modelPath;
  return Boolean(modelPath && modelPath.trim() !== "" && modelPath !== "null");
}

/**
 * Get assets that need model generation (no model path)
 */
export function getAssetsNeedingModels(parsed: ParsedGameAsset[]): ParsedGameAsset[] {
  return parsed.filter((p) => !hasValidModel(p));
}

/**
 * Get assets that have complete model paths
 */
export function getCompleteAssets(parsed: ParsedGameAsset[]): ParsedGameAsset[] {
  return parsed.filter((p) => hasValidModel(p));
}

/**
 * Convert parsed game asset back to HyperForge asset
 */
export function toHyperForgeAsset(parsed: ParsedGameAsset): HyperForgeAsset {
  return parsed.asset;
}
